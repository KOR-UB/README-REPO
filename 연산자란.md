## 연산자란?

`var x = 1;`

이중 연산자를 찾으라하면 바로 답은 "=" 이다 명칭은 대입 연산자이며 

표현식이 하나 이상의 대상 즉 표현식이 존재한다면 반드시 연산자를  수행해서 값을 변경할 수 있다.

위 의미는 x라는 변수에 1을 대입하겠다는 의미로 x라는 변수는 1에 값을 가지게 된다.

`var x = 1 + 2;`

1 + 2를 더해서 x에 대입한다. + 또한 더하기 위해 사용하는 연산자이다.

var x = 1;

x += 3; 

이런식으로 단축해서 사용하거나 상황에 따라 바로 대입해줄 수도 있다.

연산자의 종류는 정말 많다 간단하게 정리하자면 

산술 연산자, 논리 연산자, 할당 연산자, 비교 연산자, 삼항 연산자

그 외에 ,를 찍어 같은 키워드에 변수를 여러개 초기화할때 사용하면 쉼표 연산자나

new 처럼 기존 객체를 새로운 객체로 생성해서 처리하는 경우 (this 값을 처리할 경우 많이 사용한다.)



### 산술연산자 

먼저 산술연산자는 피연산자를 연산하기 위해 산술을 사용하는 것이며 이항 산술과 단항 산술로 나눌 수 있다.

이항 산술 연산에 2개에 피연산자를 연산하며 특징은 피 연산자에 값이 바뀌는 경우가 없다. 이것을 부수 효과가 없다고 한다.

x = 1 + 2; 를 사용한다고 가정하면 =은 할당 연산자이니 나중에 소개하겠다 1 + 2에 피연산자 1과 2가 존재한다. 이 들을 연산할 때 피연산자인 1 과 2는 절때 바뀌지 않는다.

방금 사용한 +(더하기)를 포함해서 -(빼기) , *(곱셈) , /(나눗셈) , % (나머지) 이렇게 5가지 이항 산술 연산자가 있다.

이부분은 수학과 매우 유사하기 때문에 디테일한 설명은 생략하고 단항 산술 연산을 알아보자

단항 산술 연산자중 부수 효과가 발생하는 두가지 부터 확인해보자

var x = 1;

var y = x;

console.log(y++);

이렇게 사용한다면 로그에 찍히는 y 값은 1이다.

y++가 의미하는 것은 저게 선언하고 난 다음 코드 줄엔 x에 1이 더해진 값을 반환한다는 것이다.

즉 저기서 콘솔 로그를 하나 더 추가해서 console.log(y)를 출력한다고 가정한다면 결과값으로 y의 값은 2로 나올것이다

var x = 1;

var y = x;

console.log(y++); //결과는 1

console.log(y); //결과는 2

같은 y이지만 이전에 증가를 표현하는 ++ 연산자를 사용했기 때문에 다음 값에 1이 증가했다 이 값은 1 외에는 증가하지 않는다 무조건 1씩 증가하며 반대로 --연산자를 사용하면 무조건 1씩 감소한다.

하지만 중요한 것은 ++를 어디다 사용하느냐가 중요하다.

예를 들어

var x = 1;

var y = x;

console.log(++y);

console.log(y--);

console.log(y);

console.log(--x);

위 결과값은 순차적으로 

2

2

1

0

이라는 결과를 반환한다

++나 --가 피연산자에 앞에 붙는지 뒤에 붙는지에 따라 연산 결과가 다르다

앞에다가 붙이는 것은 미리 1을 증감하고 그 결과값을 출력하지만 반대로 뒤에다가 붙이면 일단 현재 값을 출력한 후 1을 증감하는 것이다.

단항 산술 연산자는 피연산자를 하나만 사용하며 부수효과가 발생한다 하지만 부수 효과가 발생 하지 않는 다른 단항 산술 연산자가 하나 더 있다

바로 -이다 빼기랑 같은 연산 기호이지만 피연산자가 하나이거나 할때 그 값을 음수로 변환한다 반대로 +연산도 있지만 예는 우리가 지금껏 사용해왔다 +연산은 따로 명시해주지를 않아도 기본으로 +라는 단항 산술 연산이 자동으로 들어갔다고 보면 편하다

수학을 할때도 +5 + +3 이런식으로 하지 않기 때문에 +는 따로 처리하지 않아도 된다

하지만 수학을 할때에도 -3 + - 3 이런식에 연산은 보았을 것이다. 즉 -는 명시를 해줘야한다

이들은 그냥 흔히보는 양수냐 음수냐를 판별하는 용도일 뿐 부수효과가 발생하지 않는다.

 다음은 문자열 연산자이다.

이전에는 숫자로 된 피연산자 혹은 피연산자가 변수로 숫자를 할당 받은 친구들을 연산했지만

이번엔 문자를 산술 연산할 수 있다.

const str = "1" + 2;

위 결과 값은 12 이다 정확히는 문자 "12" 이다

문자는 숫자보다 더 높은 우선 순위를 가지게된다. 즉 문자를 피 연산자로 받는 순간 그 변수의 데이터 타입은 무조건 문자열(스트링) 타입을 가지게 된다.

하지만 문자열로 바뀌기 이전에 연산을 준 후 문자열로 변환하도록 할 수 있다

예를 들어

var str =  99 + 1 + "2"; 에 결과값은

9912일거라고 생각할 수 있지만 정답은

1002 이다

문자열이 마지막에 선언 되었으며 그 이전까지는 숫자 연산을 먼저 했다는 것이다

그러면 반대로

var str =  "2" + 99 + 1;

문자열을 먼저 넣어보다

위 결과는 문자열이 먼저 선언 되었다 그렇기 때문에 먼저 스트링값으로 형변환이 이루어 지며 

결과값은 2991이 된다는 것이다.



### 할당 연산자

var x = 1;

우리는 이것을 x에 1을 할당해주었다고 표현한다.

=은 대입연산자이며 변수를 초기화할때 혹은 재할당할때 반드시 필요한 연산자이기도 하다.

하지만 방금 사용한

+=연산과 같이 산술 연산처럼 대입할 수 있는 할당 연산자들도 존재한다

사용법은 이항 산술 연산자에 대입연산자를 추가로 섞었다고 보면 간단하다

=

+=

-=

*=

/=

%=

이렇게 6가지 할당 연산자가 있으며 이들에 특징은 부수 효과가 발생한다는 것이다 즉 피연산자에 그 값을 대입했기 때문에 그 피연산자에 값은 변하게 된다는 것이다.

 ### 비교 연산자

조건문에 핵심이자 필수인 비교 연산자는 다음과 같은 방식으로 사용할 수 있다.

조건문 if를 사용했을 때로 예시를 들겠다 만약에 ~라면 실행하도록 조건을 주는 조건문으로 설명하기 가장 간단하다.

```
var x = 1;

var y = 2;

var z = "1";

if(x == z)

{

  console.log("x와 z는 동등합니다")

}

if(x === z)

{

  console.log("서로 일치합니다")

}

if(x != y)

{

  console.log("x와 y는 불동등합니다.");

}

if(x != z)

{

  console.log("x와 z는 불동등합니다.");

}

if(x !== z)

{

  console.log("x와 z 불일치합니다.");

}
```

결과는 

x와 z는 동등합니다

x와 y는 불동등 합니다.

x와 z는 불일치 합니다.

첫번째 if문은 정상적으로 실행 되었다.

그 이유는 x와 z는 데이터 타입은 서로 다르지만 값은 똑같다고 인식하기 때문에 동등하다고 판단한 것이다.

두번째 if문은 실행 되지 않았다 조건을 보면 서로 일치한지를 확인하는 === 비교 연산이 사용 되었다

이 연산자는 데이터 타입까지 모두 일치하는지 확인한다.

x는 넘버고 z는 스트링이라 결국 다르다고 판단되어 실행되지 않았다

세번째 if문은 실행 되었다 서로 다른데 왜 실행 되었을까 하고 보니 비교연산자에 !가 들어가있다. 이는 거짓이 true이고 true면 거짓이라는 의미를 가진다. 즉 값이 틀리면 실행해 라는 의미에 비교 연산이기 때문에 실행 되었다

네번째 if문은 실행 되지 않았다. 조건을 보니 !을 사용했고 이번엔 x와 z는 서로 다른데 실행되지 않았다. 그 이유는 !=을 사용했기 때문에 데이터 타입까지도 다 다른지를 확인하지 못했기 때문에 서로 값은 1로 갖다고 인식해서 실행되지 않았다.

다섯번째 if문은 실행되었다 이유는 !==을 사용해서 데이터 타입까지 다른지 확실하게 불일치 하는지 확인했더니 하나는 넘버고 하나는 스트링이다 그렇기 때문에 불일치 하다라는 것을 알아듣고 실행 되었다.

이제 대소 관계 비교연산자라는 것이 있다 이건 수학시간에 배웠을 내용이기 때문에 크게 설명할 내용이 없다 간단하게 정리하자면

x < y; // x가 y보다 작다면

x <= y; // x가 y보다 작거나 같다면

x > y; // x가 y보다 크다면

x >= y; // x가 y보다 크거나 같다면

방금 조건문에다가 이런식으로 대소 관계를 비교해서 실행을 시킬 수 있으며 사용법은 간단하지만 정말 좋은 기능이다. 원하는 조건에 따라 무언가를 실행시키고 싶으면 이 처럼 다양한 비교 연산자를 사용하면 된다.

### 삼항 연산자

기본적으로 처음보는 사람들은 많이 헷갈려 할 수 있는 삼항 연산자는 알고보면 엄청 쉽고 유용한 친구이다. 

사용법은

조건식 ?  조건식이 true 일때 반환값 : false 일때 반환 값

? 앞에는 조건식을 주며 참 거짓을 판단하여 트루일땐 : 왼쪽에 틀리면 : 오른쪽에 값을 반환 시켜준다

![image-20200423111438823](C:\Users\ub_note\AppData\Roaming\Typora\typora-user-images\image-20200423111438823.png)

이것은 예전에 C#을 독할할 때 삼항 연산자를 이용해서 만든 소스 코드이다

소스가 길고 복잡해보이지만 어렵지 않다

L1, L2, M1,M2, R1,R2 이라는 녀석에게 값을 줄건데 어떻게 줄 것이냐면 그 위에 다른 변수인 L1rand, L2rand, M1rand, M2rand, R1rand, R2rand라는 6개의 변수에 값에 따라서 비교하고 비교한 결과에 따라서 랜던한 값을 출력하는 메소드를 이용하여 위 6개의 변수에 따라서 그 값이 높을수록 할당받는 랜덤 수도 높게 나올 수 있도록 높아지도록 구현한 코드이다.

6개의 변수는 게임에서의 스킬이고 그 스킬 포인트 + 유저의 레벨을 곱해서 값이 올라가도록 설계 했다.  이  6개의 변수를 참조하는 새로운 변수인 L1,L2, M1, M2, R1, R2는 이들은 함수가 호출 될때마다 실행하며 그 함수를 호출하면 기술 포인트가 랜덤하게 변경되도록 구현한 것이다. 

삼항 연산자가 어떻게 사용 되었는지 L1만 기준으로 설명하자면

L1rand 라는 변수에 값이 40보다 낮으면 L1에 값을 0~8 사이에 랜덤 값을 주고 그게 아니라면 다시 L1rand에 값이 60보다 낮으면 2~15 사이에 랜덤 값을 주고  그것도 아니라면 L1rand에 값이 70보다 낮으면 3~16 사이에 랜덤 값을 주고 이런식으로 동작한다.

한 변수 안에 삼항 연산자를 여러번 사용하여 더 디테일하게 비교연산을 처리하고 그에 따라 다양한 값을 참조 할 수 있도록 설계한 것이다.

### 논리 연산자

3가지가 존재한다

|| (OR)

&& (AND)

! (NOT)

사용법은 다음과 같다

```
var x = 1;

var y = 2;

if(x === 1 || y === 3)

{

  console.log("둘중 하나라도 트루라면 트루")

}

if (x === 1 && y === 3)

{

  console.log("둘중 하나라도 false라면 false");

}

if(x == !null) 

{

  console.log("x가 널이 아니라면 실행")

}
```

위 코드는 첫 번째 if와 세번째 if만 실행될 것이다 그 이유는

첫번째 조건문에선 if(x === 1) 이것은 true 이다 하지만 옆에 or 연산자가 붙고 y === 3 이것은 false이다 하지만 or 연산자는 하나라도 true 라면 true를 발환한다

두번째 조건문에선 위 조건이랑 똑같지만 논리 연산자가 다르다 and 연산자를 사용했으며

이 것은 둘 중 하나라도 틀리면 false를 반환하여 실행하지 않는다

y === 3이 아니기 때문에 실행 되지 않는다.

세번째 조건문에선 x 가 널과 동등한지 보고 있다

하지만 x는 널과 동등하지 않다 x = 1; 이라는 값을 가지고 있다.

하지만 실행 되었다 그 이유는 널 앞에 부정에 의미인 !가 붙어있기 때문이다 즉 널이 아니기 때문에 실행될 수 있다

널이나 언디파인드 값들은 이러한 NOT 을 통한 조건으로 코드를 실행시키는 경우가 많다. 

동적인 데이터를 만들때 없으면 생성하고 혹은 언디파인드면 정의해주도록 혹은 그 외에도 다양한 방법으로도 널과 언디파인드를 활용할 수 있다. 

### 그 외 연산자

#### 쉼표 연산자

var x =1,

y = 2,

z = 3;

이런식으로 사용하면

var x = 1;

var y = 2;

var z = 3; 

과 같다

앞에 키워드에 따라 같은 키워드에 변수를 새로 추가해준다.

const x = 1,

y = 2;

는

const x =1;

const y = 2; 이런것 처럼 동작한다.

#### 그룹 연산자

이건 수학을 할때에도 많이 사용해봤을 것이다.

() 소괄호로 묶은 녀석부터 우선으로 연산을 처리 하게된다.



#### typeof 연산자

내가 사용한 변수 값이 어떠한 데이터타입을 가지고 있는지 확인할 때 사용한다

이전에 1 + "1"은 스트링 값 "11"로 형변환이 된다는 것을 테스트해보았다.

하지만 로그를 찍으면 11로 나오기 때문에 1"1"이라고 생각하는 사람도 있을 것이다.

이럴 때 타입을 정확히 알아보고자 사용하는 것이 typeof 연산자이며

typeof 1 + "1"을 출력하면 결과는 스트링으로 나온다 즉 해당 데이터의 값이 아닌 타입을 알고 싶을 때 사용할 수 있다.



#### 지수 연산자

 2 ** 2 이런식으로 사용하며 거듭제곱을 해준다.



#### new 연산자

생성자 함수를 호출할 때 사용한다.

예시는 이러하다

```javascript
function NewObject(name, color) {
  this.name = name
  this.color = color
}

const newObj = new NewObject('UB', 'yellow')
console.log(newObj.name) // UB
console.log(newObj.color) // yellow
```

new obj 변수에 new 연산자로 생성자 함수를 호출했다

NewObject() 매개 변수에 name과 color 두가지를 받고

생성자 함수를 호출할 때 UB, yellow를 매개 변수로 넘겨주었다.

그 후 누가 호출했는지 알기 위해 this를 사용해서 newobj가 호출 했다는 걸 알려주고 그 this = newobj를 지목한다 그러면 this.name = newobj.name 이라는 것이다 이제 매개변수로 받은 name과 같은 값을 쓰도록 참조했다 this.color도 같은 방식으로 참조 받았다.

그 후 콘솔 로그로 newobj에 프로퍼티 name과 color를 찍으면 UB와 yellow가 출력 된다.
