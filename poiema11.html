<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>poiemaweb Clone</title>
    <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="indexcss2.css">
</head>
<body>
    <header>
        <h1>11. 원시 값과 객체의 비교</h1>
    </header>
    <div class="wraper" id="nav">
        <div class="sticky">
            <h2><a href="#"><i class="devicon-javascript-plain"></i>JAVASCRIPT</a></h2>
            <button class="listtoggle"><i class="fa fa-list-ol"></i></button>
        </div>
        <div class="max1140">
            <p>
                <a href="https://poiemaweb.com/fastcampus/type" class="link">“6. 데이터 타입”</a>에서 살펴보았듯이 자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, symbol, 객체 타입)은 크게 <em>원시 타입과 객체 타입</em>으로 구분할 수 있다. 데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유를 알아보자 원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 원시 타입과 객체 타입은 크게 세가지 측면에서 다르다.
            </p>
            <ul class="pl">
                <li>원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 이에 비해 객체 타입의 값, 즉 객체는 변경 가능한 값이다.</li>
                <li>원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.</li>
                <li>원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.</li>
            </ul>
            <div class="hiddenlist-group">
                <ul class="hiddenlist">
                    <li class="item"><a href="#1">1. 원시 값</a>
                        <ul>
                            <li><a href="#1.1">1.1 변경 불가능한 값</a></li>
                            <li><a href="#1.2">1.2 문자열과 불변성</a></li>
                            <li><a href="#1.3">1.3 값에 의한 전달</a></li>
                        </ul>
                    </li>
                    <li class="item"><a href="#2">2. 객체</a>
                        <ul>
                            <li><a href="#2.1">2.1 변경 가능한 값</a></li>
                            <li><a href="#2.2">2.2 참조에 의한 전달</a></li>
                        </ul>
                    </li>
                    <button class="listtoggle close">&times;</button>
                </ul>
            </div>
            <h2 class="index" id="1">1. 원시 값 <a href="#nav">#</a></h2>
            <h3 class="index" id="1.1">1.1 변경 불가능한 값 <a href="#nav">#</a></h3>
            <p>
                <em>원시타입의 값 즉 원시 값은 변경할 수 없는 값이다.</em> 우리가 지금까지 원시타입 변수에 값을 변경한 것은 재할당을 해서 변수 값을 교체해서 사용했다. 하지만 원시 값을 변경할 수 없다는 것이 어떤 의미일까?
            </p>
            <br>
            <p>
                우리는 <em>변수 개념을 이해할 때 새로운 값으로 재할당 시 새로운 메모리 공간에 값이 할당 되고</em> 변수 이름이 <em>그 메모리를 가리키도록</em> 변경 된다고 기억하고있다. <em>즉 메모리 주소는 바뀌게 되는 것이다.</em> 그렇게 동작하는 이유가 바로 원시 값은 변경이 불가능하기 때문이다. 원시값은 이러한 특성을 <em>불변성</em>이라고 한다. 이러한 특징을 가지는 이유는 예기치 않게 변수 값이 변경될 경우를 방지하며 상태변경을 추적할 때 용이하기 때문이다.
            </p>
            <figure>
                <img src="https://poiemaweb.com/assets/fs-images/11-1.png" alt="원시 값은 변경 불가능한 값이다.">
                <figcaption>원시 값은 변경 불가능한 값이다</figcaption>
            </figure>
            <figure>
                <img src="https://poiemaweb.com/assets/fs-images/11-2.png" alt="원시 값이 만약 변경 가능할 경우">
                <figcaption>원시 값이 변경 가능한 값인 경우</figcaption>
            </figure>
            <h3 class="index" id="1.2">1.2 문자열과 불변성 <a href="#nav">#</a></h3>
            <p>
                원시 값인 문자열은 다른 원시 값과 비교할 때 독특한 특징을 가지고있다. 문자열은 0개 이상의 문자들로 이루어진 집합이며 1개의 문자는 2byte의 메모리 공간에 저장된다. 따라서 문자열은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 결정된다. 숫자 값은 1도, 10000000도 동일한 8byte가 필요하지만 문자열의 경우 
                문자가 100개만 들어가더라 해도 약 200byte가 필요하다.
            </p>
            <dl>
                <dt>유사 배열 객체</dt>
                <dd>
                    유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며 length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수도 있다.
                    갑자기 원시값인 문자열이 객체일 수도 있다니 혼란스러울 수 있겠다. 아직 살펴보지 않았지만 원시값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다.
                </dd>
            </dl>
            <pre class="js-text">
                <code>

            <span class="keyword">const <span class="def">str </span> = </span> <span class="str">"안녕하세요"</span><em>;</em>
            <span class="def">console</span>.<span class="property">log</span>( <span class="def">str</span>[<span class="num">0</span>] )<em>;</em> <span class="log">// 안</span> 
                </code>
            </pre>
            <p>
                이처럼 문자열은 배열과 같이 접근할 수 있는 유사 배열 성격을 가지고있다.
            </p>
            <h3 class="index" id="1.3">1.3 값에 의한 전달 <a href="#nav">#</a></h3>
            <h2 class="index" id="2">2 객체 <a href="#nav">#</a></h2>
            <h3 class="index" id="2.1">2.1 변경 가능한 값 <a href="#nav">#</a></h3>
            <h3 class="index" id="2.2">2.2 참조에 의한 전달 <a href="#nav">#</a></h3>
        </div>
    </div>
    <script>
        const listtoggle = document.querySelectorAll(".listtoggle");
        const list_a = document.querySelectorAll(".hiddenlist a");
        const index_a = document.querySelectorAll(".index a");
    
        var str = "안녕하세요";
        console.log(str[0]); //안
        Array.from(index_a).forEach(index_a => index_a.addEventListener("click", NavHandler));

        function NavHandler()
        {
            const hiddenlist = document.querySelector(".hiddenlist-group");
            hiddenlist.classList.toggle("active");
        }

        Array.from(list_a).forEach(list_a => list_a.addEventListener("click",NavHandler));

        Array.from(listtoggle).forEach(listtoggle => listtoggle.addEventListener("click",NavHandler));
    </script>
</body>
</html>