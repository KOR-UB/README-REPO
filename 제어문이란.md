## 제어문이란?

제어문 이 친구는 소스 코드를 제어하기 위해  존재하는데 이 제어문을 어떻게 사용하느냐에 따라 소스 코드에 퀄리티가 상승한다. 우리는 적은 제어문으로도 다양한 행동들을 정의할 수 있다면 전문가가 될 수 있을 것이다.

#### 블록문

```
{

} 
```

이렇게 중괄호로 감싸진 곳을 코드 블록이라 한다. 블록문을 단독으로 사용할 수 있지만 하지만 대부분 단독으로 사용하지 않으며 그것은 사실상 활용도가 없다.

보통 조건이나 함수, 객체등을 정의할 때 사용하며 이제 블록문들을 기준으로 스코프가 발생하게 된다.

스코프란 일단 간단하게 지역이라고 많이 표현하며 지역이 같은 위치에 있는 변수들을 참조할 수 있다.

```
{
	var x = 10;	
	{
		console.log(x); //10 
		var y = 20;
	}
	console.log(y) //20
}
```

```
{
	var x = 10;	
	{
		console.log(x); //10 
		let y = 20;
	}
	console.log(y); //error
}
```

위 코드를 비교했을 때 정말 중요한 문제가 있다.

y에 키워드가 var랑 let 두 차이만 있을뿐 코드에 실행 순서는 사람이 보기엔 같아보인다. 하지만 두번 째에서 y값은 에러가 발생한다.

그 이유는 호이스팅 개념을 알게되면 이해할 수 있게 되지만 일단 간단하게 설명하자면 두번 째 처럼 에러가 나는 것이 정답이다. 에러가 꼭 틀린것은 아니다. 에러가 발생해야 문제를 해결할 수 있다. 위에는 마치 에러를 숨긴 것과 같은 위험한 코드이다. 하지만 호이스팅 개념을 알게된다면 사실 큰 문제는 없다.

블록문은 방금 설명하듯이 참조할 수 있는 영역이 정해져있다.

두번 째 에서 현재 log(y)를 찍은 곳 주변에 변수 y가 존재하지 않는다 그 지역 안에 있는 다른 지역 안에서 y가 유효할 뿐이다. 즉 에러가 정답이다.

하지만 위에서 에러가 나지 않은 이유는 변수 호이스팅이라는 것이 발생하는데 그 때  var라는 키워드를 가진 변수와 객체라고 불리는 친구들은 상단으로 끌어올려진다. 즉 위에 선언한 var는

```
var x;
var y;
{
	x = 10;
	{
		console.log(x);
		y = 20;
	}
	console.log(y);
}
```

와 같다고 보면 된다.  먼저 변수 y가 생겼으므로 y를 읽을 수 있으며 y에 값 20 또한 로그를 찍기 이전에 값이 할당되었으므로 y에 로그 값은 20으로 출력 되는 것이다.

이것이 var에 키워드에 장점이자 단점인 것이다. 사람이 볼 수 있는 블록문에 개념이 완전히 무너져버린다. 대신 자유롭게 어디서든 할당할 수 있다라는 장점도 가지고 있긴 하지만 코드가 길어질수록 혹은 나 혼자 짜는 코드가 아닌 협업을해서 코드를 작성하는 경우 이것은 치명적인 독이 된다.

앞으로 let과 const를 사용해야 블록문에 개념이 무너지지 않기 때문에 이제부터 var 키워드를 사용하지 않겠다.

### 조건문

모든 컴퓨터 언어는 이 제어문만 사용해서 코드를 짜더라도 어떠한 것이든 구현할 수 있다 그것은 바로 if문이다.

#### if문

if문은 만약에 라는 의미를 가지고 있다.

```
const x = 10;
if(x > 9) //만약에 x가 9보다 크다면
{
	//코드 블럭 내부를 실행한다.
	console.log(x); // 10
}
```

와 같은 의미를 지닌다. 

하지만 그 조건이 아닌 경우에 다른 것을 실행하고 싶을 경우 else라는 것을 사용한다.

#### if~else문

```
const x = 10;
if(x > 11) //x가 11보다 크지 않기 때문에 실행되지 않음
{
	console.log(x);
}
else //위에 조건이 아니라면
{
	console.log(x) //10
}
```

그리고 만약 조건식을 여러개 주고싶은 경우 else if를 사용하면 된다.

#### else if

```
const x = 10;
if(x > 20) //x가 20보다 크지 않기 때문에 실행되지 않음
{
	console.log(x);
}
else if(x > 10) //x가 10보다 크지 않기 때문에 실행되지 않음
{
	console.log(x)
}
else if(x > 5)
{
	console.log(x); //10
}
else if(x > 1) //조건은 맞지만 이미 위에서 실행했기 때문에 실행되지 않는다.
{
	console.log(x); //10
}
else
{
	console.log(x);
}
```

조건식을 여러개 붙여 해당 조건이 맞을 때 까지 else if 조건을 검사한다.

하지만 문제가 있다. 나는 조건이 맞으면 여러번 쓰고 싶었지만 위에서 조건이 맞아 이미 실행했기 때문에 그 아래에 있는 else if(x > 1) 가 실행되지 않았다.

그럴 때는 그냥 if문을 여러개 쓰면 해결할 수 있지만 좋은 방법은 아니다. else if는 true인걸 찾으면 그거 한번만 실행 후 다른 else if는 실행하지 않는다.

여러번 실행하고자 할때 쓰는 것은 바로 반복문이라는 제어문이다.

일단 else if와 되게 유사하지만 코드가 좀 더 짧게 간결하게 쓸 수 있는 친구가 하나 더 있다. 바로 스위치 문이다.

#### switch 문

스위치 문은 표현식을 평가하며 그 값과 일치하는 값을 찾는다. 잘쓰면 유용하고 if else가 10번 실행될 때 보다 실행 속도도 빠르며 하드디스크에 저장되는 메모리도 조금 아낄 수 있다. 가독성도 훨씬 좋다.

사용법은

 

```
const x = 10;

switch (x)
{
	case 2: //x 값이 2이면 아래 있는걸 실행해라
	console.log(x);
	break; //실행하면 빠져 나와라
    case 4: //x 값이 4이면 아래 있는걸 실행해라
	console.log(x);
	break; //실행하면 빠져 나와라	
	case 6: //x 값이 6이면 아래 있는걸 실행해라
	console.log(x);
	break; //실행하면 빠져 나와라	
	case 8: //x 값이 8이면 아래 있는걸 실행해라
	console.log(x);
	break; //실행하면 빠져 나와라	
	case 10: //x 값이 10이면 아래 있는걸 실행해라 x값이 10이기 때문에 실행된다.
	console.log(x); //10
	break; //실행하면 빠져 나와라
	default: //else와 같다. 위에 조건이 다 맞지 않으면 아래를 실행해라
	console.log(x); 
	break; 실행하면 빠져나와라..디폴트는 선언 안해줘도 빠져나간다 그렇기 때문에 안써줘도 된다
}
```

주석을 너무 많이 달아서 가독성이 떨어지지만 주석을 지우면 가독성이 오른다

```
const x = 10;

switch (x)
{
	case 2:
	console.log(x);
	break;
    case 4:
	console.log(x);
	break;	
	case 6:
	console.log(x);
	break; 	
	case 8:
	console.log(x);
	break;
	case 10: //이것이 실행된다
	console.log(x); 
	break;
	default:
	console.log(x); 
	break;
}
```

주석을 지우면 이렇게 조금 더 간결하게 보인다.

다음은 스타벅스 클론 코딩을 할 때 공지사항을 3초마다 바꿔주고 그 공지에 따라 공지 문자와 href 위치를 바꿔주는 코드를 작성해보았다.

![](C:\Users\YUBI\Documents\GitHub\README-REPO\Image\Switch.PNG)

a태그를 가져오고 함수를 호출시킨 후 3초마다 재호출하도록 했으며 함수가 호출될 때 마다 반복자를 의미하는 i에 값을 1씩 증가시킨 후 마지막에 0으로 다시 재할당해주고 다시 바로 함수를 호출시켜 처음 문자를 보여주며  무한루프를 돌도록 만들었다.

![](C:\Users\YUBI\Documents\GitHub\README-REPO\Image\Switchgif.gif)



### 반복문

반복문은 크게 for문과 while 문이 존재한다.

반복문은 조건식의 결과를 평가하고 그 것이 참이면 반복한다. 즉 계속 참이면 무한 반복해서 엄청난 렉을 유발한다. 즉 결국엔 거짓이라는 값이 될동안 반복시켜야 한다는 것이다

for문과 while문에 사용법은 간단하게 for문은 주어진 갯수만큼 반복시키고자할 때 사용하며 while문은 갯수는 모르겠지만 조건이 참이면 반복하고자 하는 용도로 많이 사용한다. 사용해보자

#### for문

```
const x = 10;
for (let i = 0; i < x; i++) //i에 값을 0으로 초기화 후. i가 x(10)보다 작으면 아래 코드 블록을 실행한 후 i를 1 증가시킨다 i는 반복자를 의미하는 iteration의 약자이다. 그 외에 for문 안에 for문을 돌경우 2중 for문 이라 하는데 그럴 경우 반복자를 돕는 j를 선언해주는 경우가 많다.
{
	console.log(i);
}
```

결과는

0

1

2

3

4

5

6

7

8

9

라는 결과가 나오게 된다. 총 10번 실행한 것을 볼 수 있다. 이렇게 몇번 반복할지 정해진 값 x(10)나 혹은 길이들을 의미하는 값들이 있을 경우 그 만큼 반복시키고자할 때 for문을 사용한다.

#### while 문

사용법을 이해하기 어려운 반복문이기도 하지만 잘 쓰면 정말 좋은 제어문인 while문이다.

while문은 do while 문이라는 먼저 실행한 후 반복하는 제어문도 존재한다.

do while은 반드시 한번은 실행한다. 일단 while문 부터 사용해보자

```
let x = 10;
while (x > 0) //x가 0보다 크면 반복한다.
{
	console.log(x);
}
```

위 코드는 for문을 포함해서 반복자에서 하지 말아야할 코드이다.

실행이 되어 x값이 출력될 것이지만 브라우저 혹은 vscode는 멈춰버릴 것이다. 저장을 생활화 하지 않았다면 지금까지 쓴 코드가 모두 날라갈 수 있는 아주 위험한 코드이다.

위 코드는 x는 0보다 크기 때문에 console.log(x)가 무한으로 실행된다는 의미이다. 과부화가 발생하는 것이다. 이럴 때 해결책은

```
let x = 10;
while (x > 0) //x가 0보다 크면 반복한다.
{
	x--; //x를 1감소한다.
	console.log(x);
}
```

결과값은

9

8

7

6

5

4

3

2

1

0

x값이 1씩 감소해서 이러한 결과가 된 것을 알 수 있다.

큰 문제는 아니지만 길이만큼 반복시켰다 위에 코드는 for문으로 돌리는 것이 가독성이 더 높다.  while문은 그럼 어떨 때 사용하는가? while문은 참일 때 실행하도록 하는 것이 좋다. 그리고 브레이크를 사용하여 특정 원하는 조건이 만족되면 빠져나오도록 사용한다. 이 사용법은 어렵지만 잘쓰면 전문성을 가지게 된다. 즉 남들이 볼때 오 코드좀 짤줄 아는놈인가? 라는 인식을 받을 수 있다는 것이다.

반복문에 무한 루프로 인해 골머리를 쓴 사람들은 반복문이 위험하다 생각해서 사용을 기피하는 경향이 있다. 하지만 그것은 잘못된 방법이다. 반복문 없이 if문을 사용한다고 가정해보자.

x를 0까지 1씩 감소시켜야 하며 한번 감소 될때마다 x값을 호출해야하는 퀴즈가 있다고 가정해보자

```
if (x > 0) {
    x--;
    console.log(x); //9
    if (x > 0) {
        x--;
        console.log(x); //8
        if (x > 0) {
            x--;
            console.log(x); //7
            if (x > 0) {
                x--;
                console.log(x); //6
                if (x > 0) {
                    x--;
                    console.log(x); //5
                    if (x > 0) {
                        x--;
                        console.log(x); //4
                        if (x > 0) {
                            x--;
                            console.log(x); //3
                            if (x > 0) {
                                x--;
                                console.log(x); //2
                                if (x > 0) {
                                    x--;
                                    console.log(x); //1
                                    if (x > 0) {
                                        x--;
                                        console.log(x); //0
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
```

10번만 반복했을 뿐인데 가독성이 안드로메다로 가버렸다.

```
let x = 10;
while (x > 0) //x가 0보다 크면 반복한다.
{
	x--; //x를 1감소한다.
	console.log(x);
}
```

위에 방금 짠 코드랑 같은 실행 결과지만 압도적인 가독성 차이를 보인다. x값이 100이라고 생각한다면 그걸 다 if문으로 돌려도 실행은 정상적이다 하지만 아래 코드는 첫 번째 줄에 x = 100이라고만 바꾸면 되는 것에 비해 위 코드는 if문을 100번 사용해야한다. 즉 하드에 저장공간을 아낄 수 있는 것은 둘째치고 개발 속도가 x값에 비례하여 배로 오른다는 것을 알 수 있다.

하지만 while문에 재대로 된 사용법을 사용하지 않았다. 한번 사용해보자

```
let i = 0; //반복하기 이전에 변수 초기화 필수 이미 초기화된 다른 변수들을 가져와도 좋다.
while (true) //무한 반복을 의미
{
	i++; //반복자 증감식
	console.log(i); //1부터 100까지 순서대로 하나하나 출력된다.
  	if (i === 100) break; //탈출! 추가로 코드가 한줄일경우 코드블럭을 생략해도 된다!
}
```

위 코드가 제대로 된 while문에 사용법이다. 응용하는 방법은 정말 다양하다 예를 들어 둠을 제어할 때 헤더 영역을 호버했을 때 좌표값 혹은 크기 등을 제어하려고 한다. 하지만 css를 사용하지 않고 자바스크립트로만 제어한다고 가정했을 때 그 원하는 크기나 좌표만큼 값을 증가 혹은 감소 시키다가 원하는 값을 if문으로 비교했을 때 그것과 같으면 break;  해서 탈출하면 서서히 좌표 혹은 크기가 원하는 결과 까지 빠르게 증감하다가 목표치에 도달했을 때 빠져나올것이다. 그 외에도 다양한 사용방법이 있겠지만 while문을 사용하면 몇번 반복할지 모르지만 우리가 원하는 값을 도출할 때까지 반복하고자 할 경우 while문을 사용할 것이다. while 그저 빛...

do while문은 조금 특이하다 코드 블록을 일단 먼저 실행한다 그 후 조건을 판별해서 조건이 참이면 반복한다

```
let x = 10; 

do {
    x--; x를 1 감소시킨다.
    console.log(x); //9
} while(x < 0) //x가 0보다 작으면 반복한다 즉 실행되지 않는다.
```

결과값은 9 이다. 특이하게도 반복하기 이전에 한번 실행하는 역할을 한다.



우리는 지금까지 break; 라는 명령어를 통해 반복문을 빠져나오기만 했다. 하지만 break 만큼이나 중요한 continue;를 사용하지 않았다.

컨티뉴를 한번 사용해보자

컨티뉴는 일단 반복문을 다시 실행할 때 사용한다. 즉 컨티뉴 다음에 실행 되고자 하는 부분을 무시하고 다시 반복문을 실행한다.

```
let x = 10;
for (let i = 0; i < 10; i++) //i가 10보다 작으면 반복하며 아래 실행 후 i를 1 증가
{
    console.log(i); //i를 출력
    if(i < 5) //i가 5보다 낮으면
    {
        continue; //다시 반복문을 처음부터 실행 즉 밑에 있는 콘솔 로그는 실행되지 않는다.
    }
    console.log(i + "컨티뉴 없음") //원래 컨티뉴가 없으면 실행 되어야 할 것
} 
```

출력 결과는

0

1

2

3

4

5

5컨티뉴 없음

6

6컨티뉴 없음

7

7컨티뉴 없음

8

8컨티뉴 없음

9

9컨티뉴 없음

이러하다 즉 컨티뉴가 실행되면 다음에 오는 것들은 무시되고 처음부터 다시 반복하게 된다.